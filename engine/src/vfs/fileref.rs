//! The primary interface for quick introspection into the VFS.

use std::{iter::Iterator, marker::PhantomData};

use regex::Regex;

use super::{
	entry::{Entry, EntryKind},
	Handle, VirtualFs,
};

/// The primary interface for quick introspection into the VFS;
/// provides read access to one entry.
///
/// These are cheap to create and clone, but not meant to be stored. See [`Handle`]
/// for a type that can exist apart from the VFS; they can be generated by calling
/// [`handle`](Self::handle).
#[derive(Debug, Clone)]
pub struct FileRef<'vfs> {
	pub vfs: &'vfs VirtualFs,
	pub entry: &'vfs Entry,
	pub index: usize,
}

impl std::ops::Deref for FileRef<'_> {
	type Target = Entry;

	fn deref(&self) -> &Self::Target {
		self.entry
	}
}

impl<'vfs> FileRef<'vfs> {
	/// The returned iterator will be empty if requesting the children of a leaf node.
	pub fn child_entries(&'vfs self) -> super::Iter<&Entry> {
		match &self.entry.kind {
			EntryKind::Directory(children) => super::Iter {
				vfs: self.vfs,
				elements: children,
				current: 0,
				_phantom: PhantomData,
			},
			_ => super::Iter {
				vfs: self.vfs,
				elements: &[],
				current: 0,
				_phantom: PhantomData,
			},
		}
	}

	/// The returned iterator will be empty if requesting the children of a leaf node.
	pub fn child_refs(&'vfs self) -> super::Iter<FileRef> {
		match &self.entry.kind {
			EntryKind::Directory(children) => super::Iter {
				vfs: self.vfs,
				elements: children,
				current: 0,
				_phantom: PhantomData,
			},
			_ => super::Iter {
				vfs: self.vfs,
				elements: &[],
				current: 0,
				_phantom: PhantomData,
			},
		}
	}

	/// Note: non-recursive. Panics if used on a leaf node.
	/// Check to ensure it's a directory beforehand.
	#[must_use]
	pub fn contains_regex(&self, regex: &Regex) -> bool {
		self.child_entries().any(|h| regex.is_match(h.file_name()))
	}

	/// Returns the number of child entries this entry has, if it's a directory.
	/// If it's a leaf node, returns 0.
	#[must_use]
	pub fn child_count(&self) -> usize {
		match &self.entry.kind {
			EntryKind::Directory(children) => children.len(),
			_ => 0,
		}
	}

	#[must_use]
	pub fn handle(&self) -> Handle {
		Handle {
			index: self.index,
			generation: self.vfs.generation,
		}
	}
}
